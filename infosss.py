# -*- coding: utf-8 -*-
"""ExtracionInfo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ndM9bZfCuldSLa9IqlZ7T0kB-1OTtRse
"""

import csv
import json
from unidecode import unidecode
import os

"""PRIMERO NOS CENTRAMOS EN EXTRAER LA INFORMACION DE LOS ARCHIVOS

Se debe escoger desde la interfaz la carpeta donde estan los archivos con la informacion de los pacientes, no importa si hay diferentes tipos de archivos:

AHORA, EXTRAEMOS LA INFORMACION DE LOS PACIENTES DE CADA UNO DE LOS DIFERENTES FORMATOS
Para ello, primero definimos funcion especificas para extraer la informacion de cada formato:
"""

#INICIEMOS CON EL FORMATO CSV

def quitar_tildes_diccionario(diccionario):
    diccionario_sin_tildes = {}
    for clave, valor in diccionario.items():
        if isinstance(valor, str):
            diccionario_sin_tildes[clave] = unidecode(valor)
        else:
            diccionario_sin_tildes[clave] = valor
    return diccionario_sin_tildes

def detectar_delimitador(archivo):
    with open(archivo, 'r', encoding='utf-8') as f:
        dialecto = csv.Sniffer().sniff(f.read(1024))  # Analizar solo una porción del archivo
        return dialecto.delimiter

def extraer_info_csv(nombre_archivo):
    pacientes = []
    # Ruta de la carpeta
    ruta_carpeta = './pacientes/'
    info_pacientes_csv = []
    ruta = ruta_carpeta + nombre_archivo
    delimitador = detectar_delimitador(ruta)
    with open(ruta, encoding='utf-8') as file:
        content = csv.reader(file , delimiter=delimitador)
        for row in content:
            info_pacientes_csv.append(row)

    # Eliminar el BOM si está presente en la primera fila
    if info_pacientes_csv and info_pacientes_csv[0][0].startswith('\ufeff'):
        info_pacientes_csv[0][0] = info_pacientes_csv[0][0][1:]

    for pacient in info_pacientes_csv[1:]:
        paciente = {}
        for i in range(len(pacient)):
            paciente[info_pacientes_csv[0][i].strip()] = unidecode(pacient[i])
        pacientes.append(paciente)

    return pacientes

#AHORA PARA LA INFO DE LOS JASON
def extraer_info_json(nombre_archivo):
    # Ruta de la carpeta
    ruta_carpeta = './pacientes/'
    ruta = ruta_carpeta + nombre_archivo
    with open(ruta, encoding='utf-8') as file:
        data = json.load(file)
        # Decodificar caracteres especiales utilizando unidecode
        data = [unidecode(item) if isinstance(item, str) else item for item in data]
    return data

def extraer_info_serial(nombre_archivo):
    # Ruta de la carpeta
    ruta_carpeta = './pacientes/'
    ruta = ruta_carpeta + nombre_archivo
    with open(ruta, encoding='utf8') as file:
        text = file.readlines()
    text1 = text[4].split('|')
    id, edad, nombre, apellidos, genero = text1[2],text1[4].split('^')[3],text1[12],text1[13],text1[27]
    fechaHora = text[0].split('|')[13]
    genero = genero.split('\n')[0]
    if genero == "M":
        genero = "Masculino"
    elif genero == "F":
        genero = "Femenino"
    linesOfData = [i.split('|') for i in text[6:] if fechaHora in i.split('|')]
    dic_f = {}
    data = [['{}-{}'.format(i[2].split('^')[3], i[2].split('^')[4]), i[3]] for i in linesOfData]
    dic_final = {'id': id, 'edad': edad, 'nombre': nombre, 'apellidos': apellidos, 'genero': genero}
    for j in data:
        dic_f[j[0]] = j[1]
    dic_final = {'id': id, 'edad': edad, 'nombre': nombre, 'apellidos': apellidos, 'genero': genero, 'data':dic_f}

    return [dic_final]


def infoJson2HL7(info_paciente,nombreArchivo):
    hl7_msg = []

    # Segmento MSH
    msh_segment = f"MSH|^~\&|{info_paciente['equipo']}|{info_paciente['serial']}|{info_paciente['ips']}|{info_paciente['modelo']}|{info_paciente['fecha']}||ORU^R01|{info_paciente['id']}|P|2.4"
    hl7_msg.append(msh_segment)

    # Segmento PID
    pid_segment = f"PID||{info_paciente['id']}|||{info_paciente['nombre']}^{info_paciente['apellido']}||{info_paciente['edad']}|{info_paciente['sexo']}|||||||||||||||||||"
    hl7_msg.append(pid_segment)

    # Segmento OBX (resultados del examen)
    examen = info_paciente['examen']
    for clave, valor in examen.items():
        obx_segment = f"OBX|1|NM|{clave}||{valor}||||||F"
        hl7_msg.append(obx_segment)

    # Segmento PV1 (Información de la visita)
    pv1_segment = f"PV1|1|I|{info_paciente['ingreso']}||||||{info_paciente['médico']}|{info_paciente['especialidad']}||||||||"
    hl7_msg.append(pv1_segment)

    # Segmento DG1 (Diagnóstico)
    dg1_segment = f"DG1|1|||{info_paciente['dx']}"
    hl7_msg.append(dg1_segment)

    # Segmento DG1 (Comorbilidades)
    comorbilidades = info_paciente.get('Comorbilidades', [])
    for idx, comorbilidad in enumerate(comorbilidades, start=2):
        dg1_segment = f"DG1|{idx}|||{comorbilidad}"
        hl7_msg.append(dg1_segment)

    # Convertir la lista de segmentos a una cadena de texto
    hl7_str = '\n'.join(hl7_msg)

    #Guardar el mensaje en un archivo de texto
    directory="data"
    if not os.path.exists(directory):
        os.makedirs(directory)

    filename = os.path.join(directory, nombreArchivo+'.txt')
    if os.path.exists(filename):
        creado2= "Ya existe un archivo con ese nombre"

    elif not os.path.exists(filename):
        with open(filename, 'w') as file:
            file.write(hl7_str)
        creado2= "HL7 creado correctamente"

    return [hl7_str,creado2]

def infoCSV2HL7(info_paciente,nombreArchivo):#se le ingresa como argumentos el diccionario y el nombre del archivo txt hl7, retorna una lista, donde el primer elemento es el str hl7 y el segundo es un str que indica si se creo el nuevo txt con el hl7
    hl7_msg = []

    # Segmento MSH
    msh_segment = f"MSH|^~\&|{info_paciente['equipo']}|{info_paciente['serial']}|{info_paciente['ips']}|{info_paciente['modelo']}|{info_paciente['fecha']}||ORU^R01|{info_paciente['id']}|P|2.4"
    hl7_msg.append(msh_segment)

    # Segmento PID
    pid_segment = f"PID||{info_paciente['id']}|||{info_paciente['nombre']}^{info_paciente['apellido']}||{info_paciente['edad']}|{info_paciente['sexo']}|||||||||||||||||||"
    hl7_msg.append(pid_segment)

    # Segmento OBX (resultados de los procedimientos)
    obx_segment_tp = f"OBX|1|NM|TP||{info_paciente['proc_tp']}||||||F"
    obx_segment_ptt = f"OBX|2|NM|PTT||{info_paciente['proc_ptt']}||||||F"
    obx_segment_fib = f"OBX|3|NM|FIB||{info_paciente['proc_fib']}||||||F"
    hl7_msg.extend([obx_segment_tp, obx_segment_ptt, obx_segment_fib])

    # Segmento PV1 (Información de la visita)
    pv1_segment = f"PV1|1|I|{info_paciente['ingreso']}||||||{info_paciente['médico']}|{info_paciente['especialidad']}||||||||"
    hl7_msg.append(pv1_segment)

    # Segmento DG1 (Diagnóstico principal)
    dg1_segment_ppal = f"DG1|1|||{info_paciente['dx_ppal']}"
    hl7_msg.append(dg1_segment_ppal)

    #Segmento DG2 (Diagnostico secundario)
    dg2_segment_ppal = f"DG1|2|||{info_paciente['dx2']}"
    hl7_msg.append(dg2_segment_ppal)

    #Segmento DG3 (Diagnostico terciario)
    dg3_segment_ppal = f"DG1|3|||{info_paciente['dx3']}"
    hl7_msg.append(dg3_segment_ppal)

    #Segmento DG4 (Diagnostico cuaternario)
    dg4_segment_ppal = f"DG1|4|||{info_paciente['dx4']}"
    hl7_msg.append(dg4_segment_ppal)

    #Segmento DG5 (Diagnostico numero 5)
    dg5_segment_ppal = f"DG1|5|||{info_paciente['dx5']}"
    hl7_msg.append(dg5_segment_ppal)

    # Convertir la lista de segmentos a una cadena de texto
    hl7_str = '\n'.join(hl7_msg)

    #Guardar el mensaje en un archivo de texto
    directory="data"
    if not os.path.exists(directory):
        os.makedirs(directory)

    filename = os.path.join(directory, nombreArchivo+'.txt')
    if os.path.exists(filename):
        creado2= "Ya existe un archivo con ese nombre"

    elif not os.path.exists(filename):
        with open(filename, 'w') as file:
            file.write(hl7_str)
        creado2= "HL7 creado correctamente"

    return [hl7_str,creado2]

def infoTXT2HL7(nombreArchivo):
    info = extraer_info_serial(nombreArchivo)

extraer_info_csv('paciente2.csv')

"""Una vez hecho el codigo que saca la informacion de cada archivo de forma ordenada y estandarizada: En una lista que contiene uno o varios diccionarios dentro, ello depende de si hay uno o varios pacientes dentro de un mismo archivo.
Se procede entonces a escanear de nuevo la carpeta donde esta la informacion, y dependiendo de la extencion de cada archivo se le aplicará uno de las funciones anteiormente creadas y se subirá la informacion a MONGO ATLAS
"""

# from pymongo import MongoClient
import pymongo

hce = pymongo.MongoClient("mongodb+srv://andros2017unisinu:andros172129@cluster0.dkrxuwh.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0")
db = hce.patients
#"mongodb+srv://andros2017unisinu:andros172129@cluster0.dkrxuwh.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0"

"""PARA ENVIAR TODOS LOS DATOS A LA BASE DE DATOS, EN CASO DE QUE ALGUNO DE LOS PACIENTES YA SE ENCUENTRE REGISTRADO, LA FUNCION RETORNARÁ UN STRING INFORMADO TAL COSA Y EL PACIENTE QUE FUE DENEGADO"""

def create():
    # Obtener la lista de archivos en la carpeta
    error=''
    # Ruta de la carpeta
    ruta_carpeta = './pacientes/'
    archivos = os.listdir(ruta_carpeta)
    # Clasificar los archivos por tipo
    for archivo in archivos:
        nombre, extension = os.path.splitext(archivo)
        if extension == '.txt':
            info = extraer_info_serial(archivo)
            for paciente in info:
                #print(paciente)
                if db.patients.find_one({"id" : {"$eq":paciente['id']}}) is None:
                    db.patients.insert_one(paciente)
                else:
                    error=error+'\n Ya hay un paciente con la id: '+paciente['id']
        elif extension == '.json':
            info=extraer_info_json(archivo)
            for paciente in info:
                #print(paciente)
                if db.patients.find_one({"id" : {"$eq":paciente['id']}}) is None:
                    db.patients.insert_one(paciente)
                else:
                    error=error+'\n Ya hay un paciente con la id: '+paciente['id']
        elif extension == '.csv':
            info=extraer_info_csv(archivo)
            for paciente in info:
                #print(paciente)
                if db.patients.find_one({"id" : {"$eq":paciente['id']}}) is None:
                    db.patients.insert_one(paciente)
                else:
                    error=error+' \n Ya hay un paciente con la id: '+paciente['id']
    return error

print(create())

"""AHORA, PARA BUSCAR DATOS EN LA BASE DE DATOS:

"Para el caso de la opción Buscar (Read), el algoritmo deberá mostrar la información en
pantalla, pero también crear un archivo de texto (.txt) que se guardará en una carpeta data,
dicho archivo tendrá una estructura HL7."
Siendo así, entonces:
"""




def find(id):
    result = [i for i in db.patients.find({"id": {"$eq": id}})]
    if not result:
        return "No se ha encontrado el ID"
    result=result[0]
    if 'proc_tp' in result:
        C=infoCSV2HL7(result,id)
    else:
        C=infoJson2HL7(result,id)
    print(C[1])
    return result
find("1122334455")

"""PARA ACTUALIZAR DATOS:"""

def update(id, valores_actualizados):
    # Crear un diccionario con los valores a actualizar
    actualizacion = {"$set": {k: v for k, v in valores_actualizados.items()}}

    # Realizar la actualización del documento
    resultado = db.patients.update_one({"id": id}, actualizacion)

    # Imprimir el resultado de la actualización
    if resultado.modified_count > 0:
        print(f"Se actualizó correctamente el documento con ID {id}.")
    else:
        print(f"No se encontró ningún documento con ID {id} para actualizar.")

update('1234567890',{"nombre": "¨Piter Parker", "sexo": "no pero ojala", "edad":"antes de cristo"})

"""PARA ELIMINAR ELEMENTOS"""

def delete(id):
    resultado = db.patients.delete_one({"id": id})
    if resultado.deleted_count == 1:
        return f"Se eliminó correctamente el documento con ID {id}."
    else:
        return f"No se encontró ningún documento con ID {id} para eliminar."

# Ejemplo de uso:
delete('1122334455')

