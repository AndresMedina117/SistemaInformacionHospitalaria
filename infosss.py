# -*- coding: utf-8 -*-
"""ExtracionInfo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ndM9bZfCuldSLa9IqlZ7T0kB-1OTtRse
"""

import csv
import json
from unidecode import unidecode
import os

"""PRIMERO NOS CENTRAMOS EN EXTRAER LA INFORMACION DE LOS ARCHIVOS

Se debe escoger desde la interfaz la carpeta donde estan los archivos con la informacion de los pacientes, no importa si hay diferentes tipos de archivos:

AHORA, EXTRAEMOS LA INFORMACION DE LOS PACIENTES DE CADA UNO DE LOS DIFERENTES FORMATOS
Para ello, primero definimos funcion especificas para extraer la informacion de cada formato:
"""

#INICIEMOS CON EL FORMATO CSV

def quitar_tildes_diccionario(diccionario):
    diccionario_sin_tildes = {}
    for clave, valor in diccionario.items():
        if isinstance(valor, str):
            diccionario_sin_tildes[clave] = unidecode(valor)
        else:
            diccionario_sin_tildes[clave] = valor
    return diccionario_sin_tildes

def detectar_delimitador(archivo):
    with open(archivo, 'r', encoding='utf-8') as f:
        dialecto = csv.Sniffer().sniff(f.read(1024))  # Analizar solo una porción del archivo
        return dialecto.delimiter

def extraer_info_csv(ruta_carpeta, nombre_archivo):
    pacientes = []
    # Ruta de la carpeta
    info_pacientes_csv = []
    ruta = ruta_carpeta + nombre_archivo
    delimitador = detectar_delimitador(ruta)
    with open(ruta, encoding='utf-8') as file:
        content = csv.reader(file, delimiter=delimitador)
        for row in content:
            info_pacientes_csv.append(row)
    
    # Eliminar el BOM si está presente en la primera fila
    if info_pacientes_csv and info_pacientes_csv[0][0].startswith('\ufeff'):
        info_pacientes_csv[0][0] = info_pacientes_csv[0][0][1:]

    for pacient in info_pacientes_csv[1:]:
        paciente = {}
        examenes = {}  # Nuevo diccionario para almacenar los elementos 'proc'
        comorbilidades = []  # Lista para almacenar las comorbilidades
        for i in range(len(pacient)):
            key = info_pacientes_csv[0][i].strip()
            value = unidecode(pacient[i])
            # Si la clave comienza con 'proc', agregar al diccionario 'examenes'
            if key.startswith('proc'):
                examenes[key] = value
            # Si la clave es 'dx_ppal', cambiarla a 'dx'
            elif key == 'dx_ppal':
                paciente['dx'] = value
            # Si la clave comienza con 'dx' pero no es 'dx_ppal', agregar a la lista 'comorbilidades'
            elif key.startswith('dx'):
                comorbilidades.append(value)
            else:
                paciente[key] = value
        # Asignar el diccionario 'examenes' como un valor en el diccionario principal bajo la clave 'examenes'
        paciente['examen'] = examenes
        # Asignar la lista de comorbilidades al diccionario principal bajo la clave 'comorbilidades'
        paciente['Comorbilidades'] = comorbilidades
        pacientes.append(paciente)
    
    return pacientes

#AHORA PARA LA INFO DE LOS JASON
def extraer_info_json(ruta_carpeta, nombre_archivo):
    # Ruta de la carpeta
    ruta = ruta_carpeta + nombre_archivo
    with open(ruta, encoding='utf-8') as file:
        data = json.load(file)
        # Decodificar caracteres especiales utilizando unidecode
        data = [unidecode(item) if isinstance(item, str) else item for item in data]
    return data

def extraer_info_serial(ruta_carpeta, nombre_archivo):
    # Ruta de la carpeta
    ruta = ruta_carpeta + nombre_archivo
    with open(ruta, encoding='utf8') as file:
        text = file.readlines()
    text1 = text[4].split('|')
    id, edad, nombre, apellidos, genero = text1[2],text1[4].split('^')[3],text1[12],text1[13],text1[27]
    fechaHora = text[0].split('|')[13]
    fecha = fechaHora[:12]
    print(fechaHora)
    genero = genero.split('\n')[0]
    if genero == "M":
        genero = "Masculino"
    elif genero == "F":
        genero = "Femenino"
    linesOfData = [i.split('|') for i in text[6:] if fechaHora in i.split('|')]
    dic_f = {}
    data = [['{}-{}'.format(i[2].split('^')[3], i[2].split('^')[4]), i[3]] for i in linesOfData]
    for j in data:
        dic_f[j[0]] = j[1]
    dic_final = {'id': id, 'edad': edad, 'nombre': nombre, 'apellido': apellidos, 'sexo': genero, 'fecha': fecha, 'examen':dic_f, 'dx':[], 'equipo':'', 'serial':'', 'ips':'', 'modelo':'','ingreso':'','médico':'','especialidad':'','Comorbilidades':''}

    return [dic_final]

def info2HL7(info_paciente,nombreArchivo):
    hl7_msg = []

    # Segmento MSH
    msh_segment = f"MSH|^~\&|{info_paciente['equipo']}|{info_paciente['serial']}|{info_paciente['ips']}|{info_paciente['modelo']}|{info_paciente['fecha']}||ORU^R01|{info_paciente['id']}|P|2.4"
    hl7_msg.append(msh_segment)

    # Segmento PID
    pid_segment = f"PID||{info_paciente['id']}|||{info_paciente['nombre']}^{info_paciente['apellido']}||{info_paciente['edad']}|{info_paciente['sexo']}|||||||||||||||||||"
    hl7_msg.append(pid_segment)

    # Segmento OBX (resultados del examen)
    examen = info_paciente['examen']
    for clave, valor in examen.items():
        obx_segment = f"OBX|1|NM|{clave}||{valor}||||||F"
        hl7_msg.append(obx_segment)

    # Segmento PV1 (Información de la visita)
    pv1_segment = f"PV1|1|I|{info_paciente['ingreso']}||||||{info_paciente['médico']}|{info_paciente['especialidad']}||||||||"
    hl7_msg.append(pv1_segment)

    # Segmento DG1 (Diagnóstico)
    dg1_segment = f"DG1|1|||{info_paciente['dx']}"
    hl7_msg.append(dg1_segment)

    # Segmento DG1 (Comorbilidades)
    comorbilidades = info_paciente.get('comorbilidades', [])
    for idx, comorbilidad in enumerate(comorbilidades, start=2):
        dg1_segment = f"DG1|{idx}|||{comorbilidad}"
        hl7_msg.append(dg1_segment)

    # Convertir la lista de segmentos a una cadena de texto
    hl7_str = '\n'.join(hl7_msg)

    #Guardar el mensaje en un archivo de texto
    directory="data"
    if not os.path.exists(directory):
        os.makedirs(directory)
    
    filename = os.path.join(directory, nombreArchivo+'.txt')
    if os.path.exists(filename):
        creado2= "Ya existe un archivo con ese nombre"
    
    elif not os.path.exists(filename):
        with open(filename, 'w') as file:
            file.write(hl7_str)
        creado2= "HL7 creado correctamente"

    return [hl7_str,creado2]

def infoTXT2HL7(nombreArchivo):
    info = extraer_info_serial(nombreArchivo)

import pymongo

hce = pymongo.MongoClient("mongodb+srv://andros2017unisinu:andros172129@cluster0.dkrxuwh.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0")
db = hce.patients


def create(path):
    # Obtener la lista de archivos en la carpeta
    error=''
    # Ruta de la carpeta
    ruta_carpeta = path
    ruta_carpeta+='\\'
    archivos = os.listdir(ruta_carpeta)
    # Clasificar los archivos por tipo
    for archivo in archivos:
        #print(archivo)
        nombre, extension = os.path.splitext(archivo)
        if extension == '.txt':
            info = extraer_info_serial(ruta_carpeta, archivo)
            for paciente in info:
                #print(paciente)
                if db.patients.find_one({"id" : {"$eq":paciente['id']}}) is None:
                    db.patients.insert_one(paciente)
                else:
                    error=error+'\n Ya hay un paciente con la id: '+paciente['id']
            pass
        elif extension == '.json':
            info=extraer_info_json(ruta_carpeta, archivo)
            for paciente in info:
                #print(paciente)
                if db.patients.find_one({"id" : {"$eq":paciente['id']}}) is None:
                    db.patients.insert_one(paciente)
                else:
                    error=error+'\n Ya hay un paciente con la id: '+paciente['id']
        elif extension == '.csv':
            info=extraer_info_csv(ruta_carpeta, archivo)
            for paciente in info:
                #print(paciente)
                if db.patients.find_one({"id" : {"$eq":paciente['id']}}) is None:
                    db.patients.insert_one(paciente)
                else:
                    error=error+' \n Ya hay un paciente con la id: '+paciente['id']
    return error

def findAll():
    return [i['id'] for i in db.patients.find()]

def find(id):
    result = [i for i in db.patients.find({"id": {"$eq": id}})]
    if not result:
        return "No se ha encontrado el ID"
    else:
        C=info2HL7(result[0],id)
    print(C[1])
    return result

def update(id, valores_actualizados):
    # Crear un diccionario con los valores a actualizar
    actualizacion = {"$set": {k: v for k, v in valores_actualizados.items()}}

    # Realizar la actualización del documento
    resultado = db.patients.update_one({"id": id}, actualizacion)

    # Imprimir el resultado de la actualización
    if resultado.modified_count > 0:
        print(f"Se actualizó correctamente el documento con ID {id}.")
    else:
        print(f"No se encontró ningún documento con ID {id} para actualizar.")

def eliminador(id):
    resultado = db.patients.delete_one({"id": id})
    if resultado.deleted_count == 1:
        return f"Se eliminó correctamente el documento con ID {id}."
    else:
        return f"No se encontró ningún documento con ID {id} para eliminar."

def updateDB(id, nombre, apellidos, edad, medico, ips, diagnostico, fecha, comorbilidades, examenes):
    update_data = {
        "$set": {
            "nombre": nombre,
            "apellido": apellidos,
            "edad": edad,
            "médico": medico,
            "ips": ips,
            "dx": diagnostico,
            "fecha": fecha,
            "Comorbilidades": comorbilidades,
            "examen": examenes
        }
    }
    result= db.patients.update_one({"id": id}, update_data)
    return result